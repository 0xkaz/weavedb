---
sidebar_position: 10
---
# Relayers

Relayers can execute queries on behalf of you using your [eip-712 signatures](https://eips.ethereum.org/EIPS/eip-712).

This comes in handy, when making cross-chain state verifications with off-chain oracles.

See an example use case to authenticate NFT owners [here](/docs/examples/relayer-nft).

![](/img/relayer-nft-2.png)

## Add Relayer Jobs

Before relayers can relay queries, relayer jobs need to be defined in the WeaveDB contract.

```javascript
/*
const schema = {
  type: "object",
  required: ["height"],
  properties: { height: { type: "number" } }
}
*/
await db.addRelayerJob("jobID", { schema, relayers })
```

#### Required Parameters

- `jobID` : an arbitrary string ID for the job.
- `schema` : a json schema for the extra data relayers will add to the query.
- `relayers` : an array of addresses allowed to execute the job. Only EVM accounts are capable of signing with eip-712.

#### Optional Parameters

- `multisig` : the number/percent of valid relayer signatures required
- `multisig_type` : a type of the relayer validation (`number` | `percent`)

:::info Multisig Types
1. If `multisig_type` is set `percent` and `multisig` is set `50`%, 2 valid signatures must be presented when there are 4 allowed `relayers`.

2. If `multisig_type` is set `number` (or `undefined`) and `multisig` is set `5`, 5 valid signatures must be presented.
:::

## Get Relayer Jobs

```javascript
await db.getRelayerJob("jobID")
```

## Remove Relayer Jobs

```javascript
await db.removeRelayerJob("jobID")
```

## Sign Jobs

Before sending a query to a relayer, you need to sign the query with a jobID.

```javascript
const data = { name: "Bob", age: 20 }
const relay_query = await db.sign("set", data, "ppl", "Bob", { jobID: "jobID" } )
/*
{
  function: "set",
  query: [data, "ppl", "Bob"],
  signature: "xyz...",
  nonce: 1,
  caller: "0xyouraddress...",
  jobID: "jobID"
}
*/
```

Then send it to one of the allowed relayers for the job.

## Relay Jobs

As a relayer, you should know what the relay query is requesting from `jobID`. `extra_data` can be added as the 3rd parameter, which must match the relay job schema defined in the contract.

```javascript
// const extra_data = { height: 180 }
await db.relay("jobID", relay_query, extra_data)
```

## Multisig Relayer

For relayer decentralization, you can require a certain `number` or `percent` of signatures for relay queries to be approved.

The multisig signatures should be personal EIP191 signatures by [PKPs](https://developer.litprotocol.com/coreConcepts/LitActionsAndPKPs/PKPs) generated by [Lit Actions](https://developer.litprotocol.com/coreConcepts/LitActionsAndPKPs/litActions). PKPs should sign the data in the format of `{ extra, jobID, params }` with `LitActions.ethPersonalSignMessageEcdsa`, and join the signature with `ethers.utils.joinSignature`.

This ensures the verifiability of relayers so WeaveDB can securely use states from other blockchains.


```javascript
// after collection signatures(sig1, sig2, sig3) from PKPs
await db.relay("jobID", relay_query, extra_data, { multisigs: [ sig1, sig2, sig3 ] })
```


#### An example Lit Action

This Lit Action will check the owner of specified `tokenID` in the query and add the `owner` as extra data, then create a valid signature for multisig relayer verification with WeaveDB.

You can ming PKPs and create Lit Actions using [Lit Explorer](https://explorer.litprotocol.com/).

```js
const go = async () => {
  for (const v of [
    infura_key,
    params,
    params.jobID,
    publicKey
  ]) {
    if (v === null || typeof v === "undefined") return
  }

  const abi = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ]

  let owner = "0x"
  const tokenID = params.query[0].tokenID
  try {
    const provider = new ethers.providers.JsonRpcProvider(
      "https://goerli.infura.io/v3/" + infura_key
    )
    owner = await new ethers.Contract(
      "0xfF2914F36A25B5E1732F4F62C840b1534Cc3cD68",
      abi,
      provider
    ).ownerOf(tokenID)
    const data = {
      extra: owner,
      jobID: params.jobID,
      params,
    }

    const sigShare = await LitActions.ethPersonalSignMessageEcdsa({
      message: JSON.stringify(data),
      publicKey,
      sigName: "sig1",
    })
    LitActions.setResponse({
      response: JSON.stringify({ message: data }),
    })
  } catch (e) {
    return
  }
}

go()
```

#### Relayer Serverless Function

Relayers can be a simple serverless function. The following is a serverless function using the NestJS api directory.

```js
const { utils } = require("ethers")
const { pluck, compose, map, filter, append } = require("ramda")
const SDK = require("weavedb-node-client")
const LitJsSdk = require("lit-js-sdk/build/index.node.js")
const contractTxId = process.env.NEXT_PUBLIC_WEAVEDB_CONTRACT_TX_ID

export default async (req, res) => {
  const params = JSON.parse(req.body)
  const tokenID = params.query[0].tokenID
  try {
    const litNodeClient = new LitJsSdk.LitNodeClient({ litNetwork: "serrano" })
    await litNodeClient.connect()
    const authSig = {
      sig: process.env.AUTHSIG_SIG,
      derivedVia: process.env.AUTHSIG_DERIVEDVIA,
      signedMessage: process.env.AUTHSIG_SIGNEDMESSAGE,
      address: process.env.AUTHSIG_ADDRESS,
    }
    const _res = await litNodeClient.executeJs({
      ipfsId: process.env.LIT_ACTION_IPFSID,
      authSig,
      jsParams: {
        infura_key: process.env.INFURA_KEY,
        params,
        publicKey: process.env.LIT_PUBLICKEY1,
        sigName: "sig1",
      },
    })
    const _sig = _res.signatures.sig1
    const sig = utils.joinSignature({
      r: "0x" + _sig.r,
      s: "0x" + _sig.s,
      v: _sig.recid,
    })
	
	// collecting multisigs from the pre-defined validator URLs
    const prs = map(v =>
      fetch(v, {
        method: "POST",
        body: JSON.stringify(params),
      }).then(v => v.json())
    )(process.env.VALIDATORS.split(","))
	
    const multisigs = compose(
	  append(sig),
      pluck("signature"),
      filter(v => v.success)
    )(await Promise.all(prs))
	
    const sdk = new SDK({
      contractTxId,
      rpc: process.env.WEAVEDB_RPC_NODE,
    })
	
	// sending a relay query with multisigs
    const tx = await sdk.relay(
      params.jobID,
      params,
      _res.response.message.extra,
      {
        multisigs,
        jobID: params.jobID,
        privateKey: process.env.RELAYER_PRIVATEKEY,
        wallet: process.env.RELAYER_ADDRESS,
      }
    )
    res.status(200).json({ success: true, tx })
  } catch (e) {
    res.status(200).json({
      success: false,
    })
    return
  }
}
```

## Use Relayer Extra Data

You can access the relayer data via `request.auth` in access control rules. For example, the following rules will set the height field to the data.

```javascript
// request.auth = { signer, relayer, jobID, extra }
const rules = {
  let: {
    "resource.newData.height": { var: "request.auth.extra.height" },
  },
  "allow set": { "==" : [{var: "request.auth.jobID"}, "jobID"] }
}

await db.setRules(rules, "ppl") // only the contract owners can set rules
```

## EVM Oracles

Using the relayer mechanism, you can set up an oracle to get any data from the Ethereum blockchain.

Coming Soon...
